// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

==== ColumnTemplate

This template has the responsibility to serve as a bridge between the entity model and the communication to a column family NoSQL database type.

The `ColumnTemplate` is the column template for the synchronous tasks.

[source,java]
----
@Inject
ColumnTemplate template;
...
Person person = new Person();
person.setAddress("Olympus");
person.setName("Artemis Good");
person.setPhones(Arrays.asList("55 11 94320121", "55 11 94320121"));
person.setNickname("artemis");

List<Person> people = Collections.singletonList(person);

Person personUpdated = template.insert(person);
template.insert(people);
template.insert(person, Duration.ofHours(1L));

template.update(person);
template.update(people);
----

For information removal and retrieval, there are `ColumnQuery` and `ColumnDeleteQuery` classes, respectively.

[source,java]
----
ColumnQuery query = select().from("Person").where("address").eq("Olympus").build();

Stream<Person> peopleWhoLiveOnOlympus = template.select(query);
Optional<Person> artemis = template.singleResult(select().from("Person").where("nickname").eq("artemis").build());

ColumnDeleteQuery deleteQuery = delete().from("Person").where("address").eq("Olympus").build();
template.delete(deleteQuery);
----


[source,java]
----
@Entity
public class Person {

    @Id("native_id")
    private long id;

    @Column
    private String name;

    @Column
    private int age;
}
----

[source,java]
----
@Inject
ColumnTemplate template;
...
List<Person> people = template.select(Person.class).where("id").gte(10).result();
// translating: select().from("Person").where("native_id").gte(10L).build();
template.delete(Person.class).where("id").eq("20").execute();
// translating: delete().from("Person").where("native_id").gte(10L).build();

----

To use a column template, just follow the CDI style and precede the field with the `@Inject` annotation.

[source,java]
----
@Inject
private ColumnTemplate template;
----

The next step is to produce a `ColumnManager`:

[source,java]
----
@Produces
public ColumnManager getManager() {
    ColumnManager manager = // instance;
    return manager;
}
----

You can work with several column database instances through CDI qualifier. To identify each database instance, make a `ColumnManager` visible for CDI by putting the `@Produces` and the `@Database` annotations in the method.

[source,java]
----
@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
private ColumnTemplate templateA;

@Inject
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
private ColumnTemplate templateB;

// producers methods
@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseA")
public ColumnManager getManagerA() {
    return manager;
}

@Produces
@Database(value = DatabaseType.COLUMN, provider = "databaseB")
public ColumnManager getManagerB() {
    return manager;
}
----