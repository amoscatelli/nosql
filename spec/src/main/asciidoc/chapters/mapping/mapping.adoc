// Copyright (c) 2022 Contributors to the Eclipse Foundation
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

== Introduction to the Mapping API

The mapping level, to put it differently, has the same goals as either the JPA or ORM. In the NoSQL world, the *OxM* then converts the entity object to a communication model.

This level is in charge to perform integration among technologies such as Bean Validation. The Mapping API has annotations that make the Java developerâ€™s life easier. As a communication project, it must be extensible and configurable to keep the diversity of NoSQL database.

To go straight and cover the four NoSQL types, this API has four domains:

* `jakarta.nosql.mapping.column`
* `jakarta.nosql.mapping.document`
* `jakarta.nosql.mapping.graph`
* `jakarta.nosql.mapping.keyvalue`

IMPORTANT: The package name might change on the Jakarta EE process.

=== The Mapping structure

The mapping API has five parts:

* The *persistence-core*: The mapping common project where there are annotations commons among the NoSQL types APIs.
* The *persistence-key-value*: The mapping to key-value NoSQL database.
* The *persistence-column*: The mapping to column NoSQL database.
* The *persistence-document*: The mapping to document NoSQL database.
* The *persistence-graph*: The mapping to Graph NoSQL database.

TIP: Each module works separately as a Communication API.

IMPORTANT: Similar to the communication API, there is a support for database diversity. This project has extensions for each database types on the database mapping level.

include::annotations.adoc[]

=== Template classes

The Template offers convenient creation, update, delete, and query operations for databases. The `Template` instance is the root implementation for all types. So, each database type will support this instance.

[source,java]
----
@Inject
Template template;


Book book = Book.builder().id(id).title("Java Concurrency in Practice")
.author("Brian Goetz").year(Year.of(2006)).edition(1).build();
template.insert(book);
Optional<Book> optional = template.find(Book.class, id);
System.out.println("The result " + optional);
template.delete(Book.class, id);
----

Furthermore, in the CRUD operation, Template has two queries, fluent-API for either select or delete entities; thus, Template offers the capability for search and remove beyond the ID attribute.

[source,java]
----
@Inject
Template template;

List<Book> books = template.select(Book.class).where("author").eq("Joshua Bloch").and("edition").gt(3).result();

template.select(Book.class).where("author").eq("Joshua Bloch").and("edition").gt(3).execute();
----

include::template_key_value.adoc[]
include::template_column.adoc[]
include::template_document.adoc[]
include::template_graph.adoc[]
include::mapping_query.adoc[]
